/* eslint-disable */

// @ts-nocheck

// This file was automatically generated by @caffeinelabs/bindgen@0.1.0.
// You should NOT make any changes in this file as it will be overwritten.
// Additionally, you should also exclude this file from your linter and/or formatter to prevent it from being checked or modified.

import { Actor, HttpAgent, type HttpAgentOptions, type ActorConfig, type Agent, type ActorSubclass } from "@icp-sdk/core/agent";
import type { Principal } from "@icp-sdk/core/principal";
import { idlFactory, type _SERVICE } from "./declarations/backend.did";
export interface Some<T> {
    __kind__: "Some";
    value: T;
}
export interface None {
    __kind__: "None";
}
export type Option<T> = Some<T> | None;
function some<T>(value: T): Some<T> {
    return {
        __kind__: "Some",
        value: value
    };
}
function none(): None {
    return {
        __kind__: "None"
    };
}
function isNone<T>(option: Option<T>): option is None {
    return option.__kind__ === "None";
}
function isSome<T>(option: Option<T>): option is Some<T> {
    return option.__kind__ === "Some";
}
function unwrap<T>(option: Option<T>): T {
    if (isNone(option)) {
        throw new Error("unwrap: none");
    }
    return option.value;
}
function candid_some<T>(value: T): [T] {
    return [
        value
    ];
}
function candid_none<T>(): [] {
    return [];
}
function record_opt_to_undefined<T>(arg: T | null): T | undefined {
    return arg == null ? undefined : arg;
}
export class ExternalBlob {
    _blob?: Uint8Array<ArrayBuffer> | null;
    directURL: string;
    onProgress?: (percentage: number) => void = undefined;
    private constructor(directURL: string, blob: Uint8Array<ArrayBuffer> | null){
        if (blob) {
            this._blob = blob;
        }
        this.directURL = directURL;
    }
    static fromURL(url: string): ExternalBlob {
        return new ExternalBlob(url, null);
    }
    static fromBytes(blob: Uint8Array<ArrayBuffer>): ExternalBlob {
        const url = URL.createObjectURL(new Blob([
            new Uint8Array(blob)
        ], {
            type: 'application/octet-stream'
        }));
        return new ExternalBlob(url, blob);
    }
    public async getBytes(): Promise<Uint8Array<ArrayBuffer>> {
        if (this._blob) {
            return this._blob;
        }
        const response = await fetch(this.directURL);
        const blob = await response.blob();
        this._blob = new Uint8Array(await blob.arrayBuffer());
        return this._blob;
    }
    public getDirectURL(): string {
        return this.directURL;
    }
    public withUploadProgress(onProgress: (percentage: number) => void): ExternalBlob {
        this.onProgress = onProgress;
        return this;
    }
}
export interface CheckIn {
    time: Time;
    detail: string;
    photo?: string;
}
export interface PublicProfile {
    name: string;
    dedication: Dedication;
}
export type Time = bigint;
export interface UserWithRole {
    principal: Principal;
    role: UserRole;
    profile?: UserProfile;
}
export interface KPIConfig {
    activity2name: string;
    activity1weight: number;
    activity1active: boolean;
    activity4name: string;
    activity2weight: number;
    activity2active: boolean;
    activity3weight: number;
    activity1name: string;
    activity3active: boolean;
    activity4weight: number;
    activity3name: string;
    activity4active: boolean;
    activity5weight: number;
    activity5name: string;
    activity5active: boolean;
}
export interface KPITally {
    focus: number;
    habit: number;
    flow: number;
    dedication: number;
    energy: number;
    health: number;
}
export interface InputProfile {
    name: string;
    dedication: Dedication;
}
export interface DailyReport {
    focus: string;
    focusRating: number;
    dedicationMetric: Dedication;
    strats: string;
    habit: string;
    healthRating: number;
    habitRating: number;
    flow: string;
    time: Time;
    dedication: string;
    flowRating: number;
    energyRating: number;
    dedicationRating: number;
    energy: string;
    health: string;
}
export interface CheckOut {
    time: Time;
    detail: string;
}
export interface Submission {
    kpi: KPITally;
    report: DailyReport;
    relation: number;
    time: Time;
    user: PublicProfile;
    account: string;
    rating: number;
    reflection: string;
}
export interface UserProfile {
    name: string;
    dedication: Dedication;
}
export enum Dedication {
    sales = "sales",
    technology = "technology",
    leadership = "leadership"
}
export enum UserRole {
    admin = "admin",
    user = "user",
    guest = "guest"
}
export interface backendInterface {
    _initializeAccessControlWithSecret(userSecret: string): Promise<void>;
    addCheckIn(detail: string, photo: string | null): Promise<void>;
    addCheckOut(detail: string): Promise<void>;
    addSubmission(report: DailyReport, review: string, account: string, reflection: string, relation: number, rating: number): Promise<void>;
    assignCallerUserRole(user: Principal, role: UserRole): Promise<void>;
    deleteUser(user: Principal): Promise<void>;
    getAllCheckIns(): Promise<Array<[Principal, Array<CheckIn>]>>;
    getAllCheckOuts(): Promise<Array<[Principal, Array<CheckOut>]>>;
    getAllSubmissions(): Promise<Array<[Principal, Array<Submission>]>>;
    getAllUserProfiles(): Promise<Array<[Principal, UserProfile]>>;
    getCallerUserProfile(): Promise<UserProfile | null>;
    getCallerUserRole(): Promise<UserRole>;
    getCheckIns(): Promise<Array<CheckIn>>;
    getCheckOuts(): Promise<Array<CheckOut>>;
    getKPIConfig(): Promise<KPIConfig>;
    getPublicProfile(): Promise<UserProfile>;
    getSubmissionCount(): Promise<bigint>;
    getSubmissions(): Promise<Array<Submission>>;
    getUniqueDedications(): Promise<Array<string>>;
    getUserProfile(user: Principal): Promise<UserProfile | null>;
    getUserSubmissions(user: Principal): Promise<Array<Submission>>;
    isCallerAdmin(): Promise<boolean>;
    listUsersWithRoles(): Promise<Array<UserWithRole>>;
    saveCallerUserProfile(profile: InputProfile): Promise<void>;
    saveUserProfile(profile: InputProfile): Promise<void>;
    updateKPIConfig(newConfig: KPIConfig): Promise<void>;
    updateUserRole(user: Principal, newRole: UserRole): Promise<void>;
}
import type { CheckIn as _CheckIn, DailyReport as _DailyReport, Dedication as _Dedication, InputProfile as _InputProfile, KPITally as _KPITally, PublicProfile as _PublicProfile, Submission as _Submission, Time as _Time, UserProfile as _UserProfile, UserRole as _UserRole, UserWithRole as _UserWithRole } from "./declarations/backend.did.d.ts";
export class Backend implements backendInterface {
    constructor(private actor: ActorSubclass<_SERVICE>, private _uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, private _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, private processError?: (error: unknown) => never){}
    async _initializeAccessControlWithSecret(arg0: string): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor._initializeAccessControlWithSecret(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor._initializeAccessControlWithSecret(arg0);
            return result;
        }
    }
    async addCheckIn(arg0: string, arg1: string | null): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.addCheckIn(arg0, to_candid_opt_n1(this._uploadFile, this._downloadFile, arg1));
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.addCheckIn(arg0, to_candid_opt_n1(this._uploadFile, this._downloadFile, arg1));
            return result;
        }
    }
    async addCheckOut(arg0: string): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.addCheckOut(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.addCheckOut(arg0);
            return result;
        }
    }
    async addSubmission(arg0: DailyReport, arg1: string, arg2: string, arg3: string, arg4: number, arg5: number): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.addSubmission(to_candid_DailyReport_n2(this._uploadFile, this._downloadFile, arg0), arg1, arg2, arg3, arg4, arg5);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.addSubmission(to_candid_DailyReport_n2(this._uploadFile, this._downloadFile, arg0), arg1, arg2, arg3, arg4, arg5);
            return result;
        }
    }
    async assignCallerUserRole(arg0: Principal, arg1: UserRole): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.assignCallerUserRole(arg0, to_candid_UserRole_n6(this._uploadFile, this._downloadFile, arg1));
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.assignCallerUserRole(arg0, to_candid_UserRole_n6(this._uploadFile, this._downloadFile, arg1));
            return result;
        }
    }
    async deleteUser(arg0: Principal): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.deleteUser(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.deleteUser(arg0);
            return result;
        }
    }
    async getAllCheckIns(): Promise<Array<[Principal, Array<CheckIn>]>> {
        if (this.processError) {
            try {
                const result = await this.actor.getAllCheckIns();
                return from_candid_vec_n8(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getAllCheckIns();
            return from_candid_vec_n8(this._uploadFile, this._downloadFile, result);
        }
    }
    async getAllCheckOuts(): Promise<Array<[Principal, Array<CheckOut>]>> {
        if (this.processError) {
            try {
                const result = await this.actor.getAllCheckOuts();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getAllCheckOuts();
            return result;
        }
    }
    async getAllSubmissions(): Promise<Array<[Principal, Array<Submission>]>> {
        if (this.processError) {
            try {
                const result = await this.actor.getAllSubmissions();
                return from_candid_vec_n14(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getAllSubmissions();
            return from_candid_vec_n14(this._uploadFile, this._downloadFile, result);
        }
    }
    async getAllUserProfiles(): Promise<Array<[Principal, UserProfile]>> {
        if (this.processError) {
            try {
                const result = await this.actor.getAllUserProfiles();
                return from_candid_vec_n25(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getAllUserProfiles();
            return from_candid_vec_n25(this._uploadFile, this._downloadFile, result);
        }
    }
    async getCallerUserProfile(): Promise<UserProfile | null> {
        if (this.processError) {
            try {
                const result = await this.actor.getCallerUserProfile();
                return from_candid_opt_n28(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getCallerUserProfile();
            return from_candid_opt_n28(this._uploadFile, this._downloadFile, result);
        }
    }
    async getCallerUserRole(): Promise<UserRole> {
        if (this.processError) {
            try {
                const result = await this.actor.getCallerUserRole();
                return from_candid_UserRole_n29(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getCallerUserRole();
            return from_candid_UserRole_n29(this._uploadFile, this._downloadFile, result);
        }
    }
    async getCheckIns(): Promise<Array<CheckIn>> {
        if (this.processError) {
            try {
                const result = await this.actor.getCheckIns();
                return from_candid_vec_n10(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getCheckIns();
            return from_candid_vec_n10(this._uploadFile, this._downloadFile, result);
        }
    }
    async getCheckOuts(): Promise<Array<CheckOut>> {
        if (this.processError) {
            try {
                const result = await this.actor.getCheckOuts();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getCheckOuts();
            return result;
        }
    }
    async getKPIConfig(): Promise<KPIConfig> {
        if (this.processError) {
            try {
                const result = await this.actor.getKPIConfig();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getKPIConfig();
            return result;
        }
    }
    async getPublicProfile(): Promise<UserProfile> {
        if (this.processError) {
            try {
                const result = await this.actor.getPublicProfile();
                return from_candid_UserProfile_n27(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getPublicProfile();
            return from_candid_UserProfile_n27(this._uploadFile, this._downloadFile, result);
        }
    }
    async getSubmissionCount(): Promise<bigint> {
        if (this.processError) {
            try {
                const result = await this.actor.getSubmissionCount();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getSubmissionCount();
            return result;
        }
    }
    async getSubmissions(): Promise<Array<Submission>> {
        if (this.processError) {
            try {
                const result = await this.actor.getSubmissions();
                return from_candid_vec_n16(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getSubmissions();
            return from_candid_vec_n16(this._uploadFile, this._downloadFile, result);
        }
    }
    async getUniqueDedications(): Promise<Array<string>> {
        if (this.processError) {
            try {
                const result = await this.actor.getUniqueDedications();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getUniqueDedications();
            return result;
        }
    }
    async getUserProfile(arg0: Principal): Promise<UserProfile | null> {
        if (this.processError) {
            try {
                const result = await this.actor.getUserProfile(arg0);
                return from_candid_opt_n28(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getUserProfile(arg0);
            return from_candid_opt_n28(this._uploadFile, this._downloadFile, result);
        }
    }
    async getUserSubmissions(arg0: Principal): Promise<Array<Submission>> {
        if (this.processError) {
            try {
                const result = await this.actor.getUserSubmissions(arg0);
                return from_candid_vec_n16(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getUserSubmissions(arg0);
            return from_candid_vec_n16(this._uploadFile, this._downloadFile, result);
        }
    }
    async isCallerAdmin(): Promise<boolean> {
        if (this.processError) {
            try {
                const result = await this.actor.isCallerAdmin();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.isCallerAdmin();
            return result;
        }
    }
    async listUsersWithRoles(): Promise<Array<UserWithRole>> {
        if (this.processError) {
            try {
                const result = await this.actor.listUsersWithRoles();
                return from_candid_vec_n31(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.listUsersWithRoles();
            return from_candid_vec_n31(this._uploadFile, this._downloadFile, result);
        }
    }
    async saveCallerUserProfile(arg0: InputProfile): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.saveCallerUserProfile(to_candid_InputProfile_n34(this._uploadFile, this._downloadFile, arg0));
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.saveCallerUserProfile(to_candid_InputProfile_n34(this._uploadFile, this._downloadFile, arg0));
            return result;
        }
    }
    async saveUserProfile(arg0: InputProfile): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.saveUserProfile(to_candid_InputProfile_n34(this._uploadFile, this._downloadFile, arg0));
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.saveUserProfile(to_candid_InputProfile_n34(this._uploadFile, this._downloadFile, arg0));
            return result;
        }
    }
    async updateKPIConfig(arg0: KPIConfig): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.updateKPIConfig(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.updateKPIConfig(arg0);
            return result;
        }
    }
    async updateUserRole(arg0: Principal, arg1: UserRole): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.updateUserRole(arg0, to_candid_UserRole_n6(this._uploadFile, this._downloadFile, arg1));
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.updateUserRole(arg0, to_candid_UserRole_n6(this._uploadFile, this._downloadFile, arg1));
            return result;
        }
    }
}
function from_candid_CheckIn_n11(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _CheckIn): CheckIn {
    return from_candid_record_n12(_uploadFile, _downloadFile, value);
}
function from_candid_DailyReport_n19(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _DailyReport): DailyReport {
    return from_candid_record_n20(_uploadFile, _downloadFile, value);
}
function from_candid_Dedication_n21(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _Dedication): Dedication {
    return from_candid_variant_n22(_uploadFile, _downloadFile, value);
}
function from_candid_PublicProfile_n23(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _PublicProfile): PublicProfile {
    return from_candid_record_n24(_uploadFile, _downloadFile, value);
}
function from_candid_Submission_n17(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _Submission): Submission {
    return from_candid_record_n18(_uploadFile, _downloadFile, value);
}
function from_candid_UserProfile_n27(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _UserProfile): UserProfile {
    return from_candid_record_n24(_uploadFile, _downloadFile, value);
}
function from_candid_UserRole_n29(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _UserRole): UserRole {
    return from_candid_variant_n30(_uploadFile, _downloadFile, value);
}
function from_candid_UserWithRole_n32(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _UserWithRole): UserWithRole {
    return from_candid_record_n33(_uploadFile, _downloadFile, value);
}
function from_candid_opt_n13(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: [] | [string]): string | null {
    return value.length === 0 ? null : value[0];
}
function from_candid_opt_n28(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: [] | [_UserProfile]): UserProfile | null {
    return value.length === 0 ? null : from_candid_UserProfile_n27(_uploadFile, _downloadFile, value[0]);
}
function from_candid_record_n12(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    time: _Time;
    detail: string;
    photo: [] | [string];
}): {
    time: Time;
    detail: string;
    photo?: string;
} {
    return {
        time: value.time,
        detail: value.detail,
        photo: record_opt_to_undefined(from_candid_opt_n13(_uploadFile, _downloadFile, value.photo))
    };
}
function from_candid_record_n18(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    kpi: _KPITally;
    report: _DailyReport;
    relation: number;
    time: _Time;
    user: _PublicProfile;
    account: string;
    rating: number;
    reflection: string;
}): {
    kpi: KPITally;
    report: DailyReport;
    relation: number;
    time: Time;
    user: PublicProfile;
    account: string;
    rating: number;
    reflection: string;
} {
    return {
        kpi: value.kpi,
        report: from_candid_DailyReport_n19(_uploadFile, _downloadFile, value.report),
        relation: value.relation,
        time: value.time,
        user: from_candid_PublicProfile_n23(_uploadFile, _downloadFile, value.user),
        account: value.account,
        rating: value.rating,
        reflection: value.reflection
    };
}
function from_candid_record_n20(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    focus: string;
    focusRating: number;
    dedicationMetric: _Dedication;
    strats: string;
    habit: string;
    healthRating: number;
    habitRating: number;
    flow: string;
    time: _Time;
    dedication: string;
    flowRating: number;
    energyRating: number;
    dedicationRating: number;
    energy: string;
    health: string;
}): {
    focus: string;
    focusRating: number;
    dedicationMetric: Dedication;
    strats: string;
    habit: string;
    healthRating: number;
    habitRating: number;
    flow: string;
    time: Time;
    dedication: string;
    flowRating: number;
    energyRating: number;
    dedicationRating: number;
    energy: string;
    health: string;
} {
    return {
        focus: value.focus,
        focusRating: value.focusRating,
        dedicationMetric: from_candid_Dedication_n21(_uploadFile, _downloadFile, value.dedicationMetric),
        strats: value.strats,
        habit: value.habit,
        healthRating: value.healthRating,
        habitRating: value.habitRating,
        flow: value.flow,
        time: value.time,
        dedication: value.dedication,
        flowRating: value.flowRating,
        energyRating: value.energyRating,
        dedicationRating: value.dedicationRating,
        energy: value.energy,
        health: value.health
    };
}
function from_candid_record_n24(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    name: string;
    dedication: _Dedication;
}): {
    name: string;
    dedication: Dedication;
} {
    return {
        name: value.name,
        dedication: from_candid_Dedication_n21(_uploadFile, _downloadFile, value.dedication)
    };
}
function from_candid_record_n33(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    principal: Principal;
    role: _UserRole;
    profile: [] | [_UserProfile];
}): {
    principal: Principal;
    role: UserRole;
    profile?: UserProfile;
} {
    return {
        principal: value.principal,
        role: from_candid_UserRole_n29(_uploadFile, _downloadFile, value.role),
        profile: record_opt_to_undefined(from_candid_opt_n28(_uploadFile, _downloadFile, value.profile))
    };
}
function from_candid_tuple_n15(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: [Principal, Array<_Submission>]): [Principal, Array<Submission>] {
    return [
        value[0],
        from_candid_vec_n16(_uploadFile, _downloadFile, value[1])
    ];
}
function from_candid_tuple_n26(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: [Principal, _UserProfile]): [Principal, UserProfile] {
    return [
        value[0],
        from_candid_UserProfile_n27(_uploadFile, _downloadFile, value[1])
    ];
}
function from_candid_tuple_n9(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: [Principal, Array<_CheckIn>]): [Principal, Array<CheckIn>] {
    return [
        value[0],
        from_candid_vec_n10(_uploadFile, _downloadFile, value[1])
    ];
}
function from_candid_variant_n22(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    sales: null;
} | {
    technology: null;
} | {
    leadership: null;
}): Dedication {
    return "sales" in value ? Dedication.sales : "technology" in value ? Dedication.technology : "leadership" in value ? Dedication.leadership : value;
}
function from_candid_variant_n30(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    admin: null;
} | {
    user: null;
} | {
    guest: null;
}): UserRole {
    return "admin" in value ? UserRole.admin : "user" in value ? UserRole.user : "guest" in value ? UserRole.guest : value;
}
function from_candid_vec_n10(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: Array<_CheckIn>): Array<CheckIn> {
    return value.map((x)=>from_candid_CheckIn_n11(_uploadFile, _downloadFile, x));
}
function from_candid_vec_n14(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: Array<[Principal, Array<_Submission>]>): Array<[Principal, Array<Submission>]> {
    return value.map((x)=>from_candid_tuple_n15(_uploadFile, _downloadFile, x));
}
function from_candid_vec_n16(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: Array<_Submission>): Array<Submission> {
    return value.map((x)=>from_candid_Submission_n17(_uploadFile, _downloadFile, x));
}
function from_candid_vec_n25(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: Array<[Principal, _UserProfile]>): Array<[Principal, UserProfile]> {
    return value.map((x)=>from_candid_tuple_n26(_uploadFile, _downloadFile, x));
}
function from_candid_vec_n31(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: Array<_UserWithRole>): Array<UserWithRole> {
    return value.map((x)=>from_candid_UserWithRole_n32(_uploadFile, _downloadFile, x));
}
function from_candid_vec_n8(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: Array<[Principal, Array<_CheckIn>]>): Array<[Principal, Array<CheckIn>]> {
    return value.map((x)=>from_candid_tuple_n9(_uploadFile, _downloadFile, x));
}
function to_candid_DailyReport_n2(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: DailyReport): _DailyReport {
    return to_candid_record_n3(_uploadFile, _downloadFile, value);
}
function to_candid_Dedication_n4(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: Dedication): _Dedication {
    return to_candid_variant_n5(_uploadFile, _downloadFile, value);
}
function to_candid_InputProfile_n34(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: InputProfile): _InputProfile {
    return to_candid_record_n35(_uploadFile, _downloadFile, value);
}
function to_candid_UserRole_n6(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: UserRole): _UserRole {
    return to_candid_variant_n7(_uploadFile, _downloadFile, value);
}
function to_candid_opt_n1(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: string | null): [] | [string] {
    return value === null ? candid_none() : candid_some(value);
}
function to_candid_record_n3(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    focus: string;
    focusRating: number;
    dedicationMetric: Dedication;
    strats: string;
    habit: string;
    healthRating: number;
    habitRating: number;
    flow: string;
    time: Time;
    dedication: string;
    flowRating: number;
    energyRating: number;
    dedicationRating: number;
    energy: string;
    health: string;
}): {
    focus: string;
    focusRating: number;
    dedicationMetric: _Dedication;
    strats: string;
    habit: string;
    healthRating: number;
    habitRating: number;
    flow: string;
    time: _Time;
    dedication: string;
    flowRating: number;
    energyRating: number;
    dedicationRating: number;
    energy: string;
    health: string;
} {
    return {
        focus: value.focus,
        focusRating: value.focusRating,
        dedicationMetric: to_candid_Dedication_n4(_uploadFile, _downloadFile, value.dedicationMetric),
        strats: value.strats,
        habit: value.habit,
        healthRating: value.healthRating,
        habitRating: value.habitRating,
        flow: value.flow,
        time: value.time,
        dedication: value.dedication,
        flowRating: value.flowRating,
        energyRating: value.energyRating,
        dedicationRating: value.dedicationRating,
        energy: value.energy,
        health: value.health
    };
}
function to_candid_record_n35(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    name: string;
    dedication: Dedication;
}): {
    name: string;
    dedication: _Dedication;
} {
    return {
        name: value.name,
        dedication: to_candid_Dedication_n4(_uploadFile, _downloadFile, value.dedication)
    };
}
function to_candid_variant_n5(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: Dedication): {
    sales: null;
} | {
    technology: null;
} | {
    leadership: null;
} {
    return value == Dedication.sales ? {
        sales: null
    } : value == Dedication.technology ? {
        technology: null
    } : value == Dedication.leadership ? {
        leadership: null
    } : value;
}
function to_candid_variant_n7(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: UserRole): {
    admin: null;
} | {
    user: null;
} | {
    guest: null;
} {
    return value == UserRole.admin ? {
        admin: null
    } : value == UserRole.user ? {
        user: null
    } : value == UserRole.guest ? {
        guest: null
    } : value;
}
export interface CreateActorOptions {
    agent?: Agent;
    agentOptions?: HttpAgentOptions;
    actorOptions?: ActorConfig;
    processError?: (error: unknown) => never;
}
export function createActor(canisterId: string, _uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, options: CreateActorOptions = {}): Backend {
    const agent = options.agent || HttpAgent.createSync({
        ...options.agentOptions
    });
    if (options.agent && options.agentOptions) {
        console.warn("Detected both agent and agentOptions passed to createActor. Ignoring agentOptions and proceeding with the provided agent.");
    }
    const actor = Actor.createActor<_SERVICE>(idlFactory, {
        agent,
        canisterId: canisterId,
        ...options.actorOptions
    });
    return new Backend(actor, _uploadFile, _downloadFile, options.processError);
}
